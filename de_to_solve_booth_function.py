# -*- coding: utf-8 -*-
"""DE to solve Booth Function.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MgrYehTNHjIhAzP7z2S386I03ne4YuxG

**Auto Stop with the optimal solution**
"""

import numpy as np
import matplotlib.pyplot as plt


# Dimensions and boundaries
bounds = [(-10, 10)] * 2
dimensions = len( bounds )
min_bounds, max_bounds = np.asarray( bounds ).T
bounds_range = np.fabs( min_bounds - max_bounds )

# Control parameters
crossover_probability = 0.7
population_size = 20
donor_multiplier = 0.7

# Populations
population = np.random.rand( population_size, dimensions )  # Initial random population
denormalized_population = min_bounds + population * bounds_range


def de(fobj, its):
    fitness = np.asarray( [fobj( ind ) for ind in denormalized_population] )
    best_idx = np.argmin( fitness )
    best = denormalized_population[best_idx]
    for i in range( its ):
        for j in range( population_size ):
            mutant = mutate( population, population_size, j )
            i_rand = np.random.rand( dimensions )
            cross_points = i_rand < crossover_probability
            if not np.any( cross_points ):
                cross_points[np.random.randint( 0, dimensions )] = True
            trial = np.where( cross_points, mutant, population[j] )
            trial_denorm = min_bounds + trial * bounds_range
            f = fobj( trial_denorm )
            if f < fitness[j]:
                fitness[j] = f
                population[j] = trial
                if f < fitness[best_idx]:
                    best_idx = j
                    best = trial_denorm
        yield best, fitness[best_idx]


def objective_function(x1, x2):
    return pow( (x1 + 2 * x2 - 7), 2 ) + pow( (2 * x1 + x2 - 5), 2 )


def mutate(pop, pop_size, current_index):
    indexes = [idx for idx in range( pop_size ) if idx != current_index]
    a, b, c = pop[np.random.choice( indexes, 3, replace=False )]
    return np.clip( a + donor_multiplier * (b - c), 0, 1 )


# Calculating optimal solution
optimum = False
iterations = 20
while not optimum:
    result = list( de( lambda x: objective_function( x[0], x[1] ), iterations ) )
    x, f = zip( *result )
    print(result[-1])
    if result[-1][1] == 0:
        optimum = True
    else:
        iterations += 20
    plt.plot( f, label='iteration={}'.format( iterations ) )
plt.grid()
plt.rcParams["figure.figsize"] = (750, 750)
plt.legend()

"""**Manual Checking**"""

import numpy as np
import matplotlib.pyplot as plt


def de(fobj, bounds, mut=0.8, crossp=0.7, popsize=20, its=1000):
    dimensions = len( bounds )
    pop = np.random.rand( popsize, dimensions )
    min_b, max_b = np.asarray( bounds ).T
    diff = np.fabs( min_b - max_b )
    pop_denorm = min_b + pop * diff
    fitness = np.asarray( [fobj( ind ) for ind in pop_denorm] )
    best_idx = np.argmin( fitness )
    best = pop_denorm[best_idx]
    for i in range( its ):
        for j in range( popsize ):
            idxs = [idx for idx in range( popsize ) if idx != j]
            a, b, c = pop[np.random.choice( idxs, 3, replace=False )]
            mutant = np.clip( a + mut * (b - c), 0, 1 )
            cross_points = np.random.rand( dimensions ) < crossp
            if not np.any( cross_points ):
                cross_points[np.random.randint( 0, dimensions )] = True
            trial = np.where( cross_points, mutant, pop[j] )
            trial_denorm = min_b + trial * diff
            f = fobj( trial_denorm )
            if f < fitness[j]:
                fitness[j] = f
                pop[j] = trial
                if f < fitness[best_idx]:
                    best_idx = j
                    best = trial_denorm
        yield best, fitness[best_idx]


def f_obj(x1, x2):
    return pow( (x1 + 2 * x2 - 7), 2 ) + pow( (2 * x1 + x2 - 5), 2 )


for d in range( 30, 250, 20 ):
    result = list( de( lambda x: f_obj( x[0], x[1] ), bounds=[(-10, 10)] * 2, its=d ) )
    x, f = zip( *result )
    plt.plot( f, label='iteration={}'.format( d ) )

    print(result[-1])
plt.grid()
plt.rcParams["figure.figsize"] = (750, 750)
plt.legend()

"""***Not Working properly***"""

import numpy as np
import matplotlib.pyplot as plt


def de(fobj, bounds, mut=0.8, crossp=0.7, popsize=20, its=1000):
    dimensions = len(bounds)
    pop = np.random.rand(popsize, dimensions)
    min_b, max_b = np.asarray(bounds).T
    diff = np.fabs(min_b - max_b)
    pop_denorm = min_b + pop * diff
    fitness = np.asarray([fobj(ind) for ind in pop_denorm])
    best_idx = np.argmin(fitness)
    best = pop_denorm[best_idx]
    for i in range(its):
        for j in range(popsize):
            idxs = [idx for idx in range(popsize) if idx != j]
            a, b, c = pop[np.random.choice(idxs, 3, replace=False)]
            mutant = np.clip(a + mut * (b - c), 0, 1)
            cross_points = np.random.rand(dimensions) < crossp
            if not np.any(cross_points):
                cross_points[np.random.randint(0, dimensions)] = True
            trial = np.where(cross_points, mutant, pop[j])
            trial_denorm = min_b + trial * diff
            f = fobj(trial_denorm)
            if f < fitness[j]:
                fitness[j] = f
                pop[j] = trial
                if f < fitness[best_idx]:
                    best_idx = j
                    best = trial_denorm
        yield best, fitness[best_idx]


def fobj(x1, x2):
    value = (x1 + 2 * x2 - 7) * 2 + (2 * x1 + x2 - 5) * 2
    # x1 = np.linspace(-10, 10, 30)
    # x2 = np.linspace(-10, 10, 30)

    # X, Y = np.meshgrid(x1, x2)
    # Z = z_function(X, Y)
    # ax = plt.axes(projection='3d')
    # ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
    #             cmap='winter', edgecolor='none')
    return value

for d in range(30, 270, 20):
   result = list(de(lambda x: fobj(x[0], x[1]), bounds=[(-10, 10)]*2 , its=d))
   x, f = zip(*result)
   plt.plot(f, label='iteration={}'.format(d))
   
   print(result[-1])
plt.grid() 
plt.rcParams["figure.figsize"] = (750,750) 
plt.legend()